{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "view-in-github",
        "colab_type": "text"
      },
      "source": [
        "<a href=\"https://colab.research.google.com/github/grlee1128/DS340W/blob/main/Logistic%20Regression\" target=\"_parent\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open In Colab\"/></a>"
      ]
    },
    {
      "source": [
        "# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,\n",
        "# THEN FEEL FREE TO DELETE THIS CELL.\n",
        "# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON\n",
        "# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR\n",
        "# NOTEBOOK.\n",
        "import kagglehub\n",
        "rohitrox_healthcare_provider_fraud_detection_analysis_path = kagglehub.dataset_download('rohitrox/healthcare-provider-fraud-detection-analysis')\n",
        "\n",
        "print('Data source import complete.')\n"
      ],
      "metadata": {
        "id": "MbidWL49cV20"
      },
      "cell_type": "code",
      "outputs": [],
      "execution_count": null
    },
    {
      "metadata": {
        "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
        "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
        "trusted": true,
        "id": "FO8Y51_BcV21"
      },
      "cell_type": "code",
      "source": [
        "# This Python 3 environment comes with many helpful analytics libraries installed\n",
        "# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python\n",
        "# For example, here's several helpful packages to load\n",
        "\n",
        "import numpy as np # linear algebra\n",
        "import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)\n",
        "\n",
        "# Input data files are available in the read-only \"../input/\" directory\n",
        "# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory\n",
        "\n",
        "import os\n",
        "for dirname, _, filenames in os.walk('/kaggle/input'):\n",
        "    for filename in filenames:\n",
        "        print(os.path.join(dirname, filename))\n",
        "\n",
        "# You can write up to 5GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using \"Save & Run All\"\n",
        "# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "d629ff2d2480ee46fbb7e2d37f6b5fab8052498a",
        "_cell_guid": "79c7e3d0-c299-4dcb-8224-4455121ee9b0",
        "trusted": true,
        "id": "xdOHNO1ncV22"
      },
      "cell_type": "code",
      "source": [
        "train = pd.read_csv('/kaggle/input/healthcare-provider-fraud-detection-analysis/Train-1542865627584.csv');"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "qeQTZBxtcV22"
      },
      "cell_type": "code",
      "source": [
        "train.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "paGCK0G_cV22"
      },
      "cell_type": "code",
      "source": [
        "train.shape"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "elT5hdn1cV22"
      },
      "cell_type": "code",
      "source": [
        "outpatient= pd.read_csv(\"/kaggle/input/healthcare-provider-fraud-detection-analysis/Train_Outpatientdata-1542865627584.csv\")\n",
        "outpatient.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "HXx0Y29FcV22"
      },
      "cell_type": "code",
      "source": [
        "outpatient.shape"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "CBt9BF8lcV22"
      },
      "cell_type": "code",
      "source": [
        "inpatient= pd.read_csv(\"/kaggle/input/healthcare-provider-fraud-detection-analysis/Train_Inpatientdata-1542865627584.csv\")\n",
        "inpatient.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "xR9R40pvcV23"
      },
      "cell_type": "code",
      "source": [
        "inpatient.shape"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "MMHcVO7icV23"
      },
      "cell_type": "code",
      "source": [
        "beneficiary= pd.read_csv(\"/kaggle/input/healthcare-provider-fraud-detection-analysis/Train_Beneficiarydata-1542865627584.csv\")\n",
        "beneficiary.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "PlxSLHigcV23"
      },
      "cell_type": "markdown",
      "source": [
        "## Exploratory Data Analysis"
      ]
    },
    {
      "metadata": {
        "id": "NYrQZn9rcV24"
      },
      "cell_type": "markdown",
      "source": [
        "Looking for the most common procedure codes which are applied for the fradulent and non fradulent services to see any specific pattern"
      ]
    },
    {
      "metadata": {
        "id": "VJs79g6ecV24"
      },
      "cell_type": "markdown",
      "source": [
        "### Inpatient"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "Vv2deL9ccV24"
      },
      "cell_type": "code",
      "source": [
        "df_procedures1 =  pd.DataFrame(columns = ['Procedures'])\n",
        "df_procedures1['Procedures'] = pd.concat([inpatient[\"ClmProcedureCode_1\"], inpatient[\"ClmProcedureCode_2\"], inpatient[\"ClmProcedureCode_3\"], inpatient[\"ClmProcedureCode_4\"], inpatient[\"ClmProcedureCode_5\"], inpatient[\"ClmProcedureCode_6\"]], axis=0, sort=True).dropna()\n",
        "df_procedures1['Procedures'].head(10)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "5kaCuRcCcV24"
      },
      "cell_type": "code",
      "source": [
        "df_procedures1.shape"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "ff-VI59wcV24"
      },
      "cell_type": "code",
      "source": [
        "grouped_procedure_df = df_procedures1['Procedures'].value_counts()\n",
        "grouped_procedure_df"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "bvMKoOOxcV24"
      },
      "cell_type": "code",
      "source": [
        "df_diagnosis = pd.DataFrame(columns = ['Diagnosis'])\n",
        "df_diagnosis['Diagnosis'] = pd.concat([inpatient[\"ClmDiagnosisCode_1\"], inpatient[\"ClmDiagnosisCode_2\"], inpatient[\"ClmDiagnosisCode_3\"], inpatient[\"ClmDiagnosisCode_4\"], inpatient[\"ClmDiagnosisCode_5\"], inpatient[\"ClmDiagnosisCode_6\"], inpatient[\"ClmDiagnosisCode_7\"], inpatient[\"ClmDiagnosisCode_8\"], inpatient[\"ClmDiagnosisCode_9\"], inpatient[\"ClmDiagnosisCode_10\"]], axis=0, sort=True).dropna()\n",
        "df_diagnosis['Diagnosis'].head(10)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "rRC2uKk5cV24"
      },
      "cell_type": "code",
      "source": [
        "df_diagnosis.shape"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "ePTLW8hucV24"
      },
      "cell_type": "code",
      "source": [
        "grouped_diagnosis_df = df_diagnosis['Diagnosis'].value_counts()\n",
        "grouped_diagnosis_df"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "27x_SzxWcV25"
      },
      "cell_type": "code",
      "source": [
        "grouped_procedure_df1 = grouped_procedure_df.to_frame()\n",
        "grouped_procedure_df1"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "BGDXjfS5cV25"
      },
      "cell_type": "code",
      "source": [
        "grouped_procedure_df1.columns = ['count']\n",
        "grouped_procedure_df1"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "D10doyU4cV25"
      },
      "cell_type": "code",
      "source": [
        "grouped_procedure_df1['Procedure'] = grouped_procedure_df1.index\n",
        "grouped_procedure_df1"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "9dXPoBj5cV25"
      },
      "cell_type": "code",
      "source": [
        "grouped_procedure_df1['Percentage'] = (grouped_procedure_df1['count']/sum(grouped_procedure_df1['count']))*100\n",
        "grouped_procedure_df1['Percentage']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "KeFRmqaJcV25"
      },
      "cell_type": "code",
      "source": [
        "grouped_diagnosis_df = grouped_diagnosis_df.to_frame()\n",
        "grouped_diagnosis_df.columns = ['count']\n",
        "grouped_diagnosis_df['Diagnosis'] = grouped_diagnosis_df.index\n",
        "grouped_diagnosis_df['Percentage'] = (grouped_diagnosis_df['count']/sum(grouped_diagnosis_df['count']))*100\n",
        "grouped_diagnosis_df['Percentage']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "rXcFUbfIcV25"
      },
      "cell_type": "code",
      "source": [
        "# taking only top 20\n",
        "\n",
        "plot_procedure_df1 = grouped_procedure_df1.head(20)\n",
        "plot_diagnosis_df1 = grouped_diagnosis_df.head(20)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "oWWTZEKocV25"
      },
      "cell_type": "code",
      "source": [
        "# Plotting the most commonly used diagnosis and procedures\n",
        "from matplotlib import pyplot as plt\n",
        "plot_procedure_df1['Procedure'] = plot_procedure_df1['Procedure'].astype(str)\n",
        "plot_procedure_df1.sort_values(by=['Percentage'])\n",
        "plot_procedure_df1.plot(x ='Procedure', y='Percentage', kind='bar', color ='green',\n",
        "                  title='Procedure Distribution- Inpatient', figsize=(15,10));"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "GepFXjjHcV25"
      },
      "cell_type": "code",
      "source": [
        "plot_diagnosis_df1['Diagnosis'] =  plot_diagnosis_df1['Diagnosis'].astype(str)\n",
        "plot_diagnosis_df1.sort_values(by=['Percentage'])\n",
        "plot_diagnosis_df1.plot(x ='Diagnosis', y='Percentage', kind='bar', color ='green',\n",
        "                  title='Diagnosis Distribution- Inpatient', figsize=(15,10));"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "JMfieIW4cV25"
      },
      "cell_type": "markdown",
      "source": [
        "We see that for inpatient the most common procedure used is 4019, 9904, 2724 among others\n",
        "\n",
        "We see that for inpatient the most common Diagnosis used is 4019, 2724,25000 among others"
      ]
    },
    {
      "metadata": {
        "id": "F0ftVF_0cV25"
      },
      "cell_type": "markdown",
      "source": [
        "### Outpatient"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "1Zor91oBcV25"
      },
      "cell_type": "code",
      "source": [
        "df_procedures2 =  pd.DataFrame(columns = ['Procedures'])\n",
        "df_procedures2['Procedures'] = pd.concat([outpatient[\"ClmProcedureCode_1\"], outpatient[\"ClmProcedureCode_2\"], outpatient[\"ClmProcedureCode_3\"], outpatient[\"ClmProcedureCode_4\"], outpatient[\"ClmProcedureCode_5\"], outpatient[\"ClmProcedureCode_6\"]], axis=0, sort=True).dropna()\n",
        "df_procedures2['Procedures'].head(10)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "EESh-11zcV25"
      },
      "cell_type": "code",
      "source": [
        "grouped_procedure_df2 = df_procedures2['Procedures'].value_counts()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "sLkLHMpycV26"
      },
      "cell_type": "code",
      "source": [
        "df_diagnosis2 = pd.DataFrame(columns = ['Diagnosis'])\n",
        "df_diagnosis2['Diagnosis'] = pd.concat([outpatient[\"ClmDiagnosisCode_1\"], outpatient[\"ClmDiagnosisCode_2\"], outpatient[\"ClmDiagnosisCode_3\"], outpatient[\"ClmDiagnosisCode_4\"], outpatient[\"ClmDiagnosisCode_5\"], outpatient[\"ClmDiagnosisCode_6\"], outpatient[\"ClmDiagnosisCode_7\"],  outpatient[\"ClmDiagnosisCode_8\"], outpatient[\"ClmDiagnosisCode_9\"], outpatient[\"ClmDiagnosisCode_10\"]], axis=0, sort=True).dropna()\n",
        "df_diagnosis2['Diagnosis'].head(10)\n",
        "grouped_diagnosis_df2 = df_diagnosis2['Diagnosis'].value_counts()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "6KlMBHr_cV26"
      },
      "cell_type": "code",
      "source": [
        "grouped_procedure_df_op = grouped_procedure_df2.to_frame()\n",
        "grouped_procedure_df_op.columns = ['count']\n",
        "grouped_procedure_df_op['Procedure'] = grouped_procedure_df_op.index\n",
        "grouped_procedure_df_op['Percentage'] = (grouped_procedure_df_op['count']/sum(grouped_procedure_df_op['count']))*100\n",
        "grouped_procedure_df_op['Percentage']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "usGJUJ8ccV26"
      },
      "cell_type": "code",
      "source": [
        "grouped_diagnosis_df_op = grouped_diagnosis_df2.to_frame()\n",
        "grouped_diagnosis_df_op.columns = ['count']\n",
        "grouped_diagnosis_df_op['Diagnosis'] = grouped_diagnosis_df_op.index\n",
        "grouped_diagnosis_df_op['Percentage'] = (grouped_diagnosis_df_op['count']/sum(grouped_diagnosis_df_op['count']))*100\n",
        "grouped_diagnosis_df_op['Percentage']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "Md4cL48bcV26"
      },
      "cell_type": "code",
      "source": [
        "# taking only top 20\n",
        "\n",
        "plot_procedure_df2 = grouped_procedure_df_op.head(20)\n",
        "plot_diagnosis_df2 = grouped_diagnosis_df_op.head(20)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "BwK905MIcV26"
      },
      "cell_type": "code",
      "source": [
        "# Plotting the most commonly used diagnosis and procedures\n",
        "from matplotlib import pyplot as plt\n",
        "\n",
        "\n",
        "plot_procedure_df2['Procedure'] = plot_procedure_df2['Procedure'].astype(str)\n",
        "plot_procedure_df2.sort_values(by=['Percentage'])\n",
        "plot_procedure_df2.plot(x ='Procedure', y='Percentage', kind='bar', color ='yellow',\n",
        "                   title='Procedure Distribution- Outpatient', figsize=(15,7));"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "tnRFQIpMcV26"
      },
      "cell_type": "code",
      "source": [
        "plot_diagnosis_df2['Diagnosis'] = plot_diagnosis_df2['Diagnosis'].astype(str)\n",
        "plot_diagnosis_df2.sort_values(by=['Percentage'])\n",
        "plot_diagnosis_df2.plot(x ='Diagnosis', y='Percentage', kind='bar', color ='yellow',\n",
        "                   title='Diagnosis Distribution- Outpatient', figsize=(15,7))"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "XZWmYxz6cV26"
      },
      "cell_type": "markdown",
      "source": [
        "We see a minor difference between the most used diagnosis and procedure codes between inpatient and outpatients\n",
        "\n",
        "We see that for inpatient the most common procedure used is 9904, 3722, 4516 among others\n",
        "\n",
        "We see that for inpatient the most common Diagnosis used is 4019, 25000, 2724 among others"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "3m5DoREhcV26"
      },
      "cell_type": "code",
      "source": [
        "T_fraud = train['PotentialFraud'].value_counts()\n",
        "grouped_train_df = T_fraud.to_frame()\n",
        "\n",
        "grouped_train_df.columns = ['count']\n",
        "grouped_train_df['Fraud'] = grouped_train_df.index\n",
        "grouped_train_df['Percentage'] = (grouped_train_df['count']/sum(grouped_train_df['count']))*100\n",
        "grouped_train_df['Percentage'].plot( kind='bar',color = \"blue\", title = 'Distribution')"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "1Ps3nxP0cV26"
      },
      "cell_type": "markdown",
      "source": [
        "### 2. What are the most common procedures and diagnosis codes performed by the potential fradulent providers"
      ]
    },
    {
      "metadata": {
        "id": "vO_OmF6kcV26"
      },
      "cell_type": "markdown",
      "source": [
        "### Inpatient"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "siHoX-u_cV26"
      },
      "cell_type": "code",
      "source": [
        "Train_f =  pd.DataFrame(columns = ['PotentialFraud', 'Provider'])\n",
        "Train_f = train.loc[(train['PotentialFraud'] == 'Yes')]\n",
        "Train_f"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "3hKkgr1UcV27"
      },
      "cell_type": "code",
      "source": [
        "fraud_provider_ip_df = pd.merge(inpatient, Train_f, how='inner', on='Provider')\n",
        "fraud_provider_ip_df"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "F1xfvx3CcV27"
      },
      "cell_type": "code",
      "source": [
        "len(fraud_provider_ip_df)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "jSyA0z5NcV27"
      },
      "cell_type": "code",
      "source": [
        "(len(fraud_provider_ip_df)/len(inpatient)) * 100"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "xkvLb1dicV27"
      },
      "cell_type": "markdown",
      "source": [
        "So we see there are 23402 admitted(inpatients) cases that the potential fradulent providers have interacted with at one point or the other during their services at the hospital. This is around 58% of the cases which we have in our inpatient data."
      ]
    },
    {
      "metadata": {
        "id": "5sBfdJtjcV27"
      },
      "cell_type": "markdown",
      "source": [
        "This means from our inpatient dataset for training we can have fradulent activities on more than half of them - 58% are potential fradulent encounters"
      ]
    },
    {
      "metadata": {
        "id": "RxAVWlMicV27"
      },
      "cell_type": "markdown",
      "source": [
        "### Outpatient"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "HaQGyzgYcV27"
      },
      "cell_type": "code",
      "source": [
        "fraud_provider_op_df = pd.merge(outpatient, Train_f, how='inner', on='Provider')\n",
        "fraud_provider_op_df"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "f8Bnf0JDcV27"
      },
      "cell_type": "code",
      "source": [
        "len(fraud_provider_op_df)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "7GB6UI-WcV27"
      },
      "cell_type": "code",
      "source": [
        "(len(fraud_provider_op_df)/len(outpatient))*100"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "5ldDEsfScV27"
      },
      "cell_type": "markdown",
      "source": [
        "So we see there are 189394 outpatient cases that the potential fradulent providers have interacted with at one point or the other during their services at the hospital. This is around 37% of the cases which we have in our inpatient data."
      ]
    },
    {
      "metadata": {
        "id": "uu24hcwwcV27"
      },
      "cell_type": "markdown",
      "source": [
        "This means from our outpatient dataset for training we can have fradulent activities on around 38% of encounters"
      ]
    },
    {
      "metadata": {
        "id": "Wb1BaQzFcV27"
      },
      "cell_type": "markdown",
      "source": [
        "### Which were the most used procedure codes and diagnosis codes used by the potential fradulent providers"
      ]
    },
    {
      "metadata": {
        "id": "lHu66FcqcV27"
      },
      "cell_type": "markdown",
      "source": [
        "### Inpatient"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "BfbG07nwcV27"
      },
      "cell_type": "code",
      "source": [
        "df_procedures2 =  pd.DataFrame(columns = ['Procedures'])\n",
        "df_procedures2['Procedures'] = pd.concat([fraud_provider_ip_df[\"ClmProcedureCode_1\"], fraud_provider_ip_df[\"ClmProcedureCode_2\"], fraud_provider_ip_df[\"ClmProcedureCode_3\"], fraud_provider_ip_df[\"ClmProcedureCode_4\"], fraud_provider_ip_df[\"ClmProcedureCode_5\"], fraud_provider_ip_df[\"ClmProcedureCode_6\"]], axis=0, sort=True).dropna()\n",
        "df_procedures2['Procedures'].head(10)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "f0tT5DQ0cV27"
      },
      "cell_type": "code",
      "source": [
        "grouped_F_procedure_df = df_procedures2['Procedures'].value_counts()\n",
        "grouped_F_procedure_df"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "slTDo8GBcV27"
      },
      "cell_type": "code",
      "source": [
        "grouped_F_procedure_df2 = grouped_F_procedure_df.to_frame()\n",
        "grouped_F_procedure_df2.columns = ['count']\n",
        "grouped_F_procedure_df2['Procedure'] = grouped_F_procedure_df2.index\n",
        "grouped_F_procedure_df2['Percentage'] = (grouped_F_procedure_df2['count']/sum(grouped_F_procedure_df2['count']))*100\n",
        "grouped_F_procedure_df2['Percentage']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "7vpiIt6RcV28"
      },
      "cell_type": "code",
      "source": [
        "df_diagnosis2 = pd.DataFrame(columns = ['Diagnosis'])\n",
        "df_diagnosis2['Diagnosis'] = pd.concat([fraud_provider_ip_df[\"ClmDiagnosisCode_1\"], fraud_provider_ip_df[\"ClmDiagnosisCode_2\"], fraud_provider_ip_df[\"ClmDiagnosisCode_3\"], fraud_provider_ip_df[\"ClmDiagnosisCode_4\"], fraud_provider_ip_df[\"ClmDiagnosisCode_5\"], fraud_provider_ip_df[\"ClmDiagnosisCode_6\"], fraud_provider_ip_df[\"ClmDiagnosisCode_7\"],  fraud_provider_ip_df[\"ClmDiagnosisCode_8\"], fraud_provider_ip_df[\"ClmDiagnosisCode_9\"], fraud_provider_ip_df[\"ClmDiagnosisCode_10\"]], axis=0, sort=True).dropna()\n",
        "df_diagnosis2['Diagnosis'].head(10)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "xAHoZ1WwcV28"
      },
      "cell_type": "code",
      "source": [
        "grouped_F_diagnosis_df = df_diagnosis2['Diagnosis'].value_counts()\n",
        "grouped_F_diagnosis_df"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "RwbnnyiEcV28"
      },
      "cell_type": "code",
      "source": [
        "grouped_F_diagnosis_df2 = grouped_F_diagnosis_df.to_frame()\n",
        "grouped_F_diagnosis_df2.columns = ['count']\n",
        "grouped_F_diagnosis_df2['Diagnosis'] = grouped_F_diagnosis_df2.index\n",
        "grouped_F_diagnosis_df2['Percentage'] = (grouped_F_diagnosis_df2['count']/sum(grouped_F_diagnosis_df2['count']))*100\n",
        "grouped_F_diagnosis_df2['Percentage']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "3GDWeNBOcV28"
      },
      "cell_type": "code",
      "source": [
        "plot_F_procedure_df1 = grouped_F_procedure_df2.head(20)\n",
        "\n",
        "plot_F_diagnosis_df1 = grouped_F_diagnosis_df2.head(20)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "_KwFZlNrcV28"
      },
      "cell_type": "code",
      "source": [
        "plot_F_procedure_df1.plot(x ='Procedure', y='Percentage', kind = 'bar', color ='g', figsize=(15,7))"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "i_bO6iiGcV28"
      },
      "cell_type": "code",
      "source": [
        "plot_F_diagnosis_df1.plot(x ='Diagnosis', y='Percentage', kind = 'bar', color ='y', figsize=(15,7))"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "AW7r_y9_cV28"
      },
      "cell_type": "code",
      "source": [
        "df_procedures_op2 =  pd.DataFrame(columns = ['Procedures'])\n",
        "df_procedures_op2['Procedures'] = pd.concat([fraud_provider_op_df[\"ClmProcedureCode_1\"], fraud_provider_op_df[\"ClmProcedureCode_2\"], fraud_provider_op_df[\"ClmProcedureCode_3\"], fraud_provider_op_df[\"ClmProcedureCode_4\"], fraud_provider_op_df[\"ClmProcedureCode_5\"], fraud_provider_op_df[\"ClmProcedureCode_6\"]], axis=0, sort=True).dropna()\n",
        "df_procedures_op2['Procedures'].head(10)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "70mKICtgcV28"
      },
      "cell_type": "code",
      "source": [
        "grouped_F_procedure_op_df = df_procedures_op2['Procedures'].value_counts()\n",
        "grouped_F_procedure_op_df.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "k-JPyuQfcV28"
      },
      "cell_type": "code",
      "source": [
        "grouped_F_procedure_opdf2 = grouped_F_procedure_op_df.to_frame()\n",
        "grouped_F_procedure_opdf2.columns = ['count']\n",
        "grouped_F_procedure_opdf2['Procedure'] = grouped_F_procedure_opdf2.index\n",
        "grouped_F_procedure_opdf2['Percentage'] = (grouped_F_procedure_opdf2['count']/sum(grouped_F_procedure_opdf2['count']))*100\n",
        "grouped_F_procedure_opdf2['Percentage'].head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "YBSh7-xlcV28"
      },
      "cell_type": "code",
      "source": [
        "df_diagnosis_op2 = pd.DataFrame(columns = ['Diagnosis'])\n",
        "df_diagnosis_op2['Diagnosis'] = pd.concat([fraud_provider_op_df[\"ClmDiagnosisCode_1\"], fraud_provider_op_df[\"ClmDiagnosisCode_2\"], fraud_provider_op_df[\"ClmDiagnosisCode_3\"], fraud_provider_op_df[\"ClmDiagnosisCode_4\"], fraud_provider_op_df[\"ClmDiagnosisCode_5\"], fraud_provider_op_df[\"ClmDiagnosisCode_6\"], fraud_provider_op_df[\"ClmDiagnosisCode_7\"],  fraud_provider_op_df[\"ClmDiagnosisCode_8\"], fraud_provider_op_df[\"ClmDiagnosisCode_9\"], fraud_provider_op_df[\"ClmDiagnosisCode_10\"]], axis=0, sort=True).dropna()\n",
        "df_diagnosis_op2['Diagnosis'].head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "3zbYtHaBcV28"
      },
      "cell_type": "code",
      "source": [
        "grouped_F_diagnosis_op_df = df_diagnosis2['Diagnosis'].value_counts()\n",
        "grouped_F_diagnosis_op_df.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "xCAcRs6kcV28"
      },
      "cell_type": "code",
      "source": [
        "grouped_F_diagnosis_opdf2 = grouped_F_diagnosis_op_df.to_frame()\n",
        "grouped_F_diagnosis_opdf2.columns = ['count']\n",
        "grouped_F_diagnosis_opdf2['Diagnosis'] = grouped_F_diagnosis_opdf2.index\n",
        "grouped_F_diagnosis_opdf2['Percentage'] = (grouped_F_diagnosis_opdf2['count']/sum(grouped_F_diagnosis_opdf2['count']))*100\n",
        "grouped_F_diagnosis_opdf2['Percentage'].head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "X5YW9ZgscV28"
      },
      "cell_type": "code",
      "source": [
        "plot_F_procedure_opdf1 = grouped_F_procedure_opdf2.head(20)\n",
        "\n",
        "plot_F_diagnosis_opdf1 = grouped_F_diagnosis_opdf2.head(20)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "PAVrUBSGcV28"
      },
      "cell_type": "code",
      "source": [
        "plot_F_procedure_opdf1.plot(x ='Procedure', y='Percentage', kind = 'bar', color ='g', figsize=(15,7))"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "9i2HCerTcV28"
      },
      "cell_type": "code",
      "source": [
        "plot_F_diagnosis_opdf1.plot(x ='Diagnosis', y='Percentage', kind = 'bar', color ='y', figsize=(15,7))"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "f0ZNUNPzcV28"
      },
      "cell_type": "markdown",
      "source": [
        "### 4.Which states/localities have the highest number of potential frauds"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "ili_gIx7cV28"
      },
      "cell_type": "code",
      "source": [
        "beneficiary.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "e3C_I6jqcV28"
      },
      "cell_type": "code",
      "source": [
        "fraud_beneficiary_ip_op_df = pd.merge(beneficiary, fraud_provider_ip_df, how='inner', on='BeneID')\n",
        "fraud_beneficiary_ip_op_df.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "pyHyIAd6cV29"
      },
      "cell_type": "code",
      "source": [
        "Train_F_Beneficiary_grouped = fraud_beneficiary_ip_op_df['State'].value_counts()\n",
        "Train_F_Beneficiary_grouped.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "kAOjJQpFcV29"
      },
      "cell_type": "code",
      "source": [
        "Train_F_Beneficiary_grouped1 = Train_F_Beneficiary_grouped.to_frame()\n",
        "Train_F_Beneficiary_grouped1['Count'] =  Train_F_Beneficiary_grouped1['State']\n",
        "Train_F_Beneficiary_grouped1['STATE'] = Train_F_Beneficiary_grouped1.index\n",
        "Train_F_Beneficiary_grouped1 = Train_F_Beneficiary_grouped1.drop(['State'], axis = 1)\n",
        "Train_F_Beneficiary_grouped1 = Train_F_Beneficiary_grouped1.head(20)\n",
        "Train_F_Beneficiary_grouped1"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "bWzLaxxbcV29"
      },
      "cell_type": "code",
      "source": [
        "Train_F_Beneficiary_grouped1.plot(x ='STATE', y='Count', kind = 'bar', figsize= (15,7));"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "99vWQo7PcV29"
      },
      "cell_type": "markdown",
      "source": [
        "### Average Age for the data set and as a comparison for the probable fradulent activites applied on what age range"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "-NX0tSRkcV29"
      },
      "cell_type": "code",
      "source": [
        "fraud_beneficiary_ip_op_df['DOB'] =  pd.to_datetime(fraud_beneficiary_ip_op_df['DOB'], format='%Y-%m-%d')\n",
        "now = pd.to_datetime('2009-12-01' , format = '%Y-%m-%d') # Assuming this is 2009 data as the last recorded death is for 2009\n",
        "fraud_beneficiary_ip_op_df['DOB'] = fraud_beneficiary_ip_op_df['DOB'].where(fraud_beneficiary_ip_op_df['DOB'] < now)\n",
        "fraud_beneficiary_ip_op_df['age'] = (now - fraud_beneficiary_ip_op_df['DOB']).astype('<m8[Y]')\n",
        "ax = fraud_beneficiary_ip_op_df['age'].plot.hist(bins=20, alpha=0.5, figsize=(8, 6), edgecolor='b')"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "vp3N3NT2cV29"
      },
      "cell_type": "markdown",
      "source": [
        "This seems logical as most of the patients are of an age >65"
      ]
    },
    {
      "metadata": {
        "id": "6rQ14bz3cV29"
      },
      "cell_type": "markdown",
      "source": [
        "### Inpatient data as a whole not just the fradulent activities"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "es3mThjDcV29"
      },
      "cell_type": "code",
      "source": [
        "beneficiary['DOB'] =  pd.to_datetime(beneficiary['DOB'], format='%Y-%m-%d')\n",
        "now = pd.to_datetime('2009-12-01' , format = '%Y-%m-%d') # Assuming this is 2009 data as the last recorded death is for 2009\n",
        "beneficiary['DOB'] = beneficiary['DOB'].where(beneficiary['DOB'] < now)\n",
        "beneficiary['age'] = (now - beneficiary['DOB']).astype('<m8[Y]')\n",
        "ax = beneficiary['age'].plot.hist(bins=20, alpha=0.5, figsize=(8, 6), edgecolor='b')"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "U-aPgJjKcV29"
      },
      "cell_type": "markdown",
      "source": [
        "Here too we see a similar pattern"
      ]
    },
    {
      "metadata": {
        "id": "n1Y_TzIscV29"
      },
      "cell_type": "markdown",
      "source": [
        "### What is the average cost of potential fraud claims and also what is the cost as % of whole. Checking the outliers for such claims"
      ]
    },
    {
      "metadata": {
        "id": "u9OuQv6gcV29"
      },
      "cell_type": "markdown",
      "source": [
        "### Inpatient"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "9sAfus8VcV29"
      },
      "cell_type": "code",
      "source": [
        "ax = inpatient['InscClaimAmtReimbursed'].plot.hist(bins=20, alpha=0.5, figsize=(8, 6), facecolor='g', edgecolor='g')\n",
        "# Insurance Claim amount reimbursed."
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "D5goDFpKcV29"
      },
      "cell_type": "code",
      "source": [
        "import seaborn as sns\n",
        "inpatient_1 = pd.merge(inpatient, train, how='inner', on='Provider')\n",
        "g = sns.FacetGrid(inpatient_1, col='PotentialFraud', height=8)\n",
        "g.map(plt.hist, 'InscClaimAmtReimbursed', bins=20, color = 'g')"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "W6s5t0TkcV29"
      },
      "cell_type": "markdown",
      "source": [
        "We see that it is a significantly large amount which might be fradulent."
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "XAHKo_IMcV29"
      },
      "cell_type": "code",
      "source": [
        "inpatient_1 = inpatient_1.loc[(inpatient_1['PotentialFraud'] == 'Yes')]\n",
        "Total = inpatient_1['InscClaimAmtReimbursed'].sum()\n",
        "print(Total)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "F7iik9fBcV29"
      },
      "cell_type": "markdown",
      "source": [
        "241288510 - around 240 Million dollars worth of claim might have some fradulent activity. Even if we assume that it has just 10% fradulent activity the amount will be quite huge"
      ]
    },
    {
      "metadata": {
        "id": "akWwbFnYcV29"
      },
      "cell_type": "markdown",
      "source": [
        "### Outpatient"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "FaS6FQmZcV2-"
      },
      "cell_type": "code",
      "source": [
        "ax = outpatient['InscClaimAmtReimbursed'].plot.hist(bins=100,range=[0,5000], alpha=0.5, figsize=(8, 6), facecolor='c', edgecolor='k')"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "WX4VqfYgcV2-"
      },
      "cell_type": "code",
      "source": [
        "outpatient_1 = pd.merge(outpatient, train, how='inner', on='Provider')\n",
        "g = sns.FacetGrid(outpatient_1, col='PotentialFraud', height=8)\n",
        "g.map(plt.hist, 'InscClaimAmtReimbursed', bins=20, range=[0, 5000], color ='c')"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "Zs9LneNlcV2-"
      },
      "cell_type": "markdown",
      "source": [
        "### Checking for missing values in the data set"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "waG1haCTcV2-"
      },
      "cell_type": "code",
      "source": [
        "beneficiary.isna().sum()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "qwx7654PcV2-"
      },
      "cell_type": "markdown",
      "source": [
        "Only the date of death is empty - makes sense for the people who are alive"
      ]
    },
    {
      "metadata": {
        "id": "CZZapMVccV2-"
      },
      "cell_type": "markdown",
      "source": [
        "### Adding Age Column"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "ihLO-ugPcV2-"
      },
      "cell_type": "code",
      "source": [
        "beneficiary['DOB'] = pd.to_datetime(beneficiary['DOB'] , format = '%Y-%m-%d')\n",
        "beneficiary['DOD'] = pd.to_datetime(beneficiary['DOD'],format = '%Y-%m-%d',errors='ignore')\n",
        "beneficiary['Age'] = round(((beneficiary['DOD'] - beneficiary['DOB']).dt.days)/365)\n",
        "\n",
        "## As we see that last DOD value is 2009-12-01 ,which means Beneficiary Details data is of year 2009.\n",
        "## so we will calculate age of other benficiaries for year 2009."
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "FQpLEU9XcV2-"
      },
      "cell_type": "code",
      "source": [
        "beneficiary.Age.fillna(round(((pd.to_datetime('2009-12-01' , format = '%Y-%m-%d') - beneficiary['DOB']).dt.days)/365),\n",
        "                                 inplace=True)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "azpIGpyqcV2-"
      },
      "cell_type": "code",
      "source": [
        "beneficiary.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "Vd_8gDl-cV2-"
      },
      "cell_type": "code",
      "source": [
        "## Creating the master DF\n",
        "inpatient['EncounterType'] = 0\n",
        "outpatient['EncounterType'] = 1\n",
        "frames = [inpatient, outpatient]\n",
        "TrainInAndOut = pd.concat(frames)\n",
        "TrainInAndOutBenf = pd.merge(TrainInAndOut, beneficiary, how='inner', on='BeneID')\n",
        "Master_df = pd.merge(TrainInAndOutBenf, train, how='inner', on='Provider')"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "4SrpssemcV2-"
      },
      "cell_type": "code",
      "source": [
        "Master_df.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "4OgAbWPscV2-"
      },
      "cell_type": "code",
      "source": [
        "Master_df['PotentialFraud'].value_counts()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "L9UsspNvcV2-"
      },
      "cell_type": "code",
      "source": [
        "Master_df.shape"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "bhBXun2qcV2-"
      },
      "cell_type": "code",
      "source": [
        "Master_df.isnull().sum()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "Pb8wbKlZcV2-"
      },
      "cell_type": "code",
      "source": [
        "## removing the column DOD and DOB also creating a new column IsDead as we already have the age we do not need date of death and date of birth\n",
        "\n",
        "Master_df.loc[Master_df['DOD'].isnull(), 'IsDead'] = '0'\n",
        "Master_df.loc[(Master_df['DOD'].notnull()), 'IsDead'] = '1'\n",
        "Master_df = Master_df.drop(['DOD'], axis = 1)\n",
        "Master_df = Master_df.drop(['DOB'], axis = 1)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "EzRS1YaNcV2-"
      },
      "cell_type": "code",
      "source": [
        "Master_df = Master_df.drop(['age'], axis = 1)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "VjkD8-FGcV2-"
      },
      "cell_type": "markdown",
      "source": [
        "Calculating the number of days the patient was admitted to the dospital and removing admission and discharge date, For outpatients as they do not get admitted will put number of days admitted = 0"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "sfwCu7kQcV2-"
      },
      "cell_type": "code",
      "source": [
        "Master_df['AdmissionDt'] = pd.to_datetime(Master_df['AdmissionDt'] , format = '%Y-%m-%d')\n",
        "Master_df['DischargeDt'] = pd.to_datetime(Master_df['DischargeDt'],format = '%Y-%m-%d')\n",
        "Master_df['DaysAdmitted'] = ((Master_df['DischargeDt'] - Master_df['AdmissionDt']).dt.days)+1\n",
        "Master_df.loc[Master_df['EncounterType'] == 1, 'DaysAdmitted'] = '0'\n",
        "Master_df[['EncounterType','DaysAdmitted','DischargeDt','AdmissionDt']].head()\n",
        "Master_df = Master_df.drop(['DischargeDt'], axis = 1)\n",
        "Master_df = Master_df.drop(['AdmissionDt'], axis = 1)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "OcwXINOIcV2-"
      },
      "cell_type": "code",
      "source": [
        "Master_df.loc[Master_df['DeductibleAmtPaid'].isnull(), 'DeductibleAmtPaid'] = '0'"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "yPy6i5WBcV2-"
      },
      "cell_type": "code",
      "source": [
        "cols= ['ClmAdmitDiagnosisCode', 'ClmDiagnosisCode_1', 'ClmDiagnosisCode_10',\n",
        "       'ClmDiagnosisCode_2', 'ClmDiagnosisCode_3', 'ClmDiagnosisCode_4',\n",
        "       'ClmDiagnosisCode_5', 'ClmDiagnosisCode_6', 'ClmDiagnosisCode_7',\n",
        "       'ClmDiagnosisCode_8', 'ClmDiagnosisCode_9', 'ClmProcedureCode_1',\n",
        "       'ClmProcedureCode_2', 'ClmProcedureCode_3', 'ClmProcedureCode_4',\n",
        "       'ClmProcedureCode_5', 'ClmProcedureCode_6']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "lOluFnqHcV2-"
      },
      "cell_type": "code",
      "source": [
        "Master_df[cols]= Master_df[cols].replace({np.nan:0})\n",
        "Master_df"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "LPZBP3tQcV2_"
      },
      "cell_type": "code",
      "source": [
        "for i in cols:\n",
        "    Master_df[i][Master_df[i]!=0]= 1"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "QbB2nRSacV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df[cols]= Master_df[cols].astype(float)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "4Zd0q7NdcV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df['TotalDiagnosis']= Master_df['ClmDiagnosisCode_1']+Master_df['ClmDiagnosisCode_10']+Master_df['ClmDiagnosisCode_2']+ Master_df['ClmDiagnosisCode_3']+ Master_df['ClmDiagnosisCode_4']+Master_df['ClmDiagnosisCode_5']+ Master_df['ClmDiagnosisCode_6']+ Master_df['ClmDiagnosisCode_7']+Master_df['ClmDiagnosisCode_8']+ Master_df['ClmDiagnosisCode_9']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "TxNlhN0GcV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df['TotalProcedure']= Master_df['ClmProcedureCode_1']+Master_df['ClmProcedureCode_2']+Master_df['ClmProcedureCode_3']+ Master_df['ClmProcedureCode_4']+ Master_df['ClmProcedureCode_5']+Master_df['ClmProcedureCode_6']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "O_RFkNUbcV2_"
      },
      "cell_type": "markdown",
      "source": [
        "Removing coulmns which are not necessary"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "PzZkO7OicV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df.columns"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "lPXNt3LvcV2_"
      },
      "cell_type": "code",
      "source": [
        "remove=['Provider','BeneID', 'ClaimID', 'ClaimStartDt','ClaimEndDt','AttendingPhysician',\n",
        "       'OperatingPhysician', 'OtherPhysician', 'ClmDiagnosisCode_1',\n",
        "       'ClmDiagnosisCode_2', 'ClmDiagnosisCode_3', 'ClmDiagnosisCode_4',\n",
        "       'ClmDiagnosisCode_5', 'ClmDiagnosisCode_6', 'ClmDiagnosisCode_7',\n",
        "       'ClmDiagnosisCode_8', 'ClmDiagnosisCode_9', 'ClmDiagnosisCode_10',\n",
        "       'ClmProcedureCode_1', 'ClmProcedureCode_2', 'ClmProcedureCode_3',\n",
        "       'ClmProcedureCode_4', 'ClmProcedureCode_5', 'ClmProcedureCode_6',\n",
        "       'ClmAdmitDiagnosisCode','DeductibleAmtPaid','NoOfMonths_PartACov',\n",
        "        'NoOfMonths_PartBCov','DiagnosisGroupCode',\n",
        "        'State', 'County']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "eCyw4cR6cV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df.drop(columns=remove, axis=1, inplace=True)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "iT8YMp9YcV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "yrJBhTX-cV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df.shape"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "PJhklzbScV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df['RenalDiseaseIndicator'].value_counts()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "ERq9k-YlcV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df['RenalDiseaseIndicator']= Master_df['RenalDiseaseIndicator'].replace({'Y':1,'0':0})"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "1HGZ3zuBcV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df['RenalDiseaseIndicator']=Master_df['RenalDiseaseIndicator'].astype(int)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "eP_3SkDBcV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df.describe(include='O')"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "vL_Vpn-DcV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df['IsDead']=Master_df['IsDead'].astype(float)\n",
        "Master_df['DaysAdmitted']=Master_df['DaysAdmitted'].astype(float)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "dXL5sPz4cV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df['PotentialFraud']=Master_df['PotentialFraud'].replace({'Yes':1, 'No':0})"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "H6XoPaRvcV2_"
      },
      "cell_type": "code",
      "source": [
        " Master_df['PotentialFraud']=Master_df['PotentialFraud'].astype(int)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "B2Aa0RXrcV2_"
      },
      "cell_type": "code",
      "source": [
        "Master_df['PotentialFraud']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "d8st2C-vcV2_"
      },
      "cell_type": "code",
      "source": [
        "x= Master_df.drop('PotentialFraud', axis=1)\n",
        "y= Master_df.loc[:,'PotentialFraud']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "bVqptzNZcV2_"
      },
      "cell_type": "code",
      "source": [
        "x.columns"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "b75NS09GcV2_"
      },
      "cell_type": "code",
      "source": [
        "num_col= ['InscClaimAmtReimbursed',\n",
        "       'IPAnnualReimbursementAmt', 'IPAnnualDeductibleAmt',\n",
        "       'OPAnnualReimbursementAmt', 'OPAnnualDeductibleAmt', 'Age',\n",
        "       'DaysAdmitted', 'TotalDiagnosis', 'TotalProcedure']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "tzQmWzZJcV3A"
      },
      "cell_type": "code",
      "source": [
        "numerical_columns= x.loc[:,num_col]\n",
        "numerical_columns.describe()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "K_M8fBO7cV3A"
      },
      "cell_type": "code",
      "source": [
        "numerical_columns.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "0tQqgSsjcV3A"
      },
      "cell_type": "code",
      "source": [
        "cat_col= ['EncounterType', 'Gender', 'Race',\n",
        "       'RenalDiseaseIndicator', 'ChronicCond_Alzheimer',\n",
        "       'ChronicCond_Heartfailure', 'ChronicCond_KidneyDisease',\n",
        "       'ChronicCond_Cancer', 'ChronicCond_ObstrPulmonary',\n",
        "       'ChronicCond_Depression', 'ChronicCond_Diabetes',\n",
        "       'ChronicCond_IschemicHeart', 'ChronicCond_Osteoporasis',\n",
        "       'ChronicCond_rheumatoidarthritis', 'ChronicCond_stroke','IsDead']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "w7oCuFpJcV3A"
      },
      "cell_type": "code",
      "source": [
        "x_cat= x.loc[:,cat_col]\n",
        "x_cat"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "iz_3UptPcV3A"
      },
      "cell_type": "code",
      "source": [
        "from sklearn.preprocessing import StandardScaler"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "VQTelVX2cV3A"
      },
      "cell_type": "code",
      "source": [
        "scale= StandardScaler()\n",
        "x_num= scale.fit_transform(x[num_col])"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "pQpanWC_cV3A"
      },
      "cell_type": "code",
      "source": [
        "x_num= pd.DataFrame(x_num, columns=['InscClaimAmtReimbursed','IPAnnualReimbursementAmt', 'IPAnnualDeductibleAmt','OPAnnualReimbursementAmt', 'OPAnnualDeductibleAmt', 'Age','DaysAdmitted', 'TotalDiagnosis', 'TotalProcedure'])"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "dXaiFpkpcV3A"
      },
      "cell_type": "code",
      "source": [
        "x= pd.concat([x_num, x_cat], axis=1)\n",
        "x"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "YpHRW2_ZcV3A"
      },
      "cell_type": "code",
      "source": [
        "x.columns"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "B-xj0dqTcV3A"
      },
      "cell_type": "code",
      "source": [
        "y"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "Aux0U_nhcV3A"
      },
      "cell_type": "markdown",
      "source": [
        "### Train- Test Split"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "4X4AbzFvcV3A"
      },
      "cell_type": "code",
      "source": [
        "from sklearn.model_selection import train_test_split"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "5gNpUAU2cV3A"
      },
      "cell_type": "code",
      "source": [
        "x_train,x_test, y_train, y_test= train_test_split(x,y, test_size=0.1, random_state=42)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "iwXNkohacV3A"
      },
      "cell_type": "code",
      "source": [
        "from imblearn.under_sampling import RandomUnderSampler\n",
        "rus = RandomUnderSampler(random_state=0)\n",
        "x_train1,y_train1 = rus.fit_resample(x_train, y_train)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "SG0yEqvhcV3A"
      },
      "cell_type": "code",
      "source": [
        "'''from imblearn import over_sampling\n",
        "\n",
        "ada = over_sampling.ADASYN(random_state=0)\n",
        "x_train2, y_train2 = ada.fit_resample(x_train, y_train)'''"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "WYP5TISmcV3A"
      },
      "cell_type": "code",
      "source": [
        "from sklearn.metrics import confusion_matrix, classification_report, accuracy_score, roc_auc_score, auc, roc_curve"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "4m_8ucCtcV3A"
      },
      "cell_type": "code",
      "source": [
        "from xgboost import plot_importance\n",
        "from xgboost import XGBClassifier\n",
        "xgb= XGBClassifier()\n",
        "xgb.fit(x_train,y_train)\n",
        "plot_importance(xgb)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "JYM-urlecV3A"
      },
      "cell_type": "code",
      "source": [
        "xgb= XGBClassifier()\n",
        "xgb.fit(x_train1,y_train1)\n",
        "plot_importance(xgb)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "QknJd4kDcV3A"
      },
      "cell_type": "code",
      "source": [
        "'''xgb.fit(x_train2,y_train2)\n",
        "plot_importance(xgb)'''"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "GNgvwvjQcV3A"
      },
      "cell_type": "code",
      "source": [
        "acc_score=[]"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "ss5PQnR_cV3A"
      },
      "cell_type": "markdown",
      "source": [
        "### Decision Tree"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "Yi3NCbhBcV3B"
      },
      "cell_type": "code",
      "source": [
        "from sklearn.model_selection import GridSearchCV"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "H_CsW0RecV3B"
      },
      "cell_type": "code",
      "source": [
        "from sklearn import tree\n",
        "from sklearn.tree import DecisionTreeClassifier\n",
        "estimator=  DecisionTreeClassifier()\n",
        "param_grid= {'criterion':['gini', 'entropy'],\n",
        "             'max_depth':[3,4,5],\n",
        "             'min_samples_split':[2,3,5]\n",
        "             }\n",
        "grid_search = GridSearchCV(estimator = estimator, param_grid = param_grid)\n",
        "grid_search.fit(x_train1, y_train1)\n",
        "print(grid_search.best_score_)\n",
        "print(grid_search.best_params_)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "IjN-IdEscV3B"
      },
      "cell_type": "code",
      "source": [
        "'''param_grid= {'criterion':['gini', 'entropy'],\n",
        "             'max_depth':[3,4,5],\n",
        "             'min_samples_split':[2,3,5]\n",
        "             }\n",
        "grid_search = GridSearchCV(estimator = estimator, param_grid = param_grid)\n",
        "grid_search.fit(x_train2, y_train2)\n",
        "print(grid_search.best_score_)\n",
        "print(grid_search.best_params_)'''"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "cjN0lFbVcV3B"
      },
      "cell_type": "code",
      "source": [
        "grid_search.fit(x_train, y_train)\n",
        "print(grid_search.best_score_)\n",
        "print(grid_search.best_params_)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "x4gI2cyccV3B"
      },
      "cell_type": "markdown",
      "source": [
        "### Random Forest"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "rhukEMaKcV3B"
      },
      "cell_type": "code",
      "source": [
        "from sklearn.ensemble import RandomForestClassifier\n",
        "estimator1= RandomForestClassifier()\n",
        "'''estimator1.fit(x_train, y_train)\n",
        "model_score= estimator1.predict(x_train)\n",
        "accuracy= estimator1.predict(x_test)\n",
        "print(accuracy_score(y_train, model_score))\n",
        "print(accuracy_score(y_test, accuracy))'''"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "5DgHGhqUcV3B"
      },
      "cell_type": "code",
      "source": [
        "'''estimator1.fit(x_train1, y_train1)\n",
        "model_score= estimator1.predict(x_train1)\n",
        "accuracy= estimator1.predict(x_test)\n",
        "print(accuracy_score(y_train1, model_score))\n",
        "print(accuracy_score(y_test, accuracy))'''"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "wT0h8RNVcV3B"
      },
      "cell_type": "code",
      "source": [
        "'''estimator1.fit(x_train2, y_train2)\n",
        "model_score= estimator1.predict(x_train2)\n",
        "accuracy= estimator1.predict(x_test)\n",
        "print(accuracy_score(y_train2, model_score))\n",
        "print(accuracy_score(y_test, accuracy))'''"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "AA-vU2TFcV3B"
      },
      "cell_type": "markdown",
      "source": [
        "### Naive Bayes"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "_NqI-1zTcV3B"
      },
      "cell_type": "code",
      "source": [
        "from sklearn.naive_bayes import GaussianNB\n",
        "bayes= GaussianNB()\n",
        "bayes.fit(x_train, y_train)\n",
        "train_pred= bayes.predict(x_train)\n",
        "test_pred= bayes.predict(x_test)\n",
        "print(accuracy_score(y_train,train_pred))\n",
        "print(accuracy_score(y_test,test_pred))"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "ZMgxsd9PcV3B"
      },
      "cell_type": "code",
      "source": [
        "bayes.fit(x_train, y_train)\n",
        "train_pred= bayes.predict(x_train1)\n",
        "test_pred= bayes.predict(x_test)\n",
        "print(accuracy_score(y_train1,train_pred))\n",
        "print(accuracy_score(y_test,test_pred))"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "Vdx77mUOcV3B"
      },
      "cell_type": "code",
      "source": [
        "'''bayes.fit(x_train, y_train)\n",
        "train_pred= bayes.predict(x_train2)\n",
        "test_pred= bayes.predict(x_test)\n",
        "print(accuracy_score(y_train2,train_pred))\n",
        "print(accuracy_score(y_test,test_pred))'''"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "6Dxfh8tFcV3B"
      },
      "cell_type": "markdown",
      "source": [
        "### Logistic Regression"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "HN4KJrF9cV3B"
      },
      "cell_type": "code",
      "source": [
        "from sklearn.linear_model import LogisticRegression\n",
        "lr= LogisticRegression()\n",
        "lr.fit(x_train, y_train)\n",
        "train_pred= lr.predict(x_train)\n",
        "test_pred= lr.predict(x_test)\n",
        "print(accuracy_score(y_train,train_pred))\n",
        "print(accuracy_score(y_test,test_pred))"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "QN71CcUpcV3B"
      },
      "cell_type": "code",
      "source": [
        "lr.fit(x_train1, y_train1)\n",
        "train_pred= lr.predict(x_train1)\n",
        "test_pred= lr.predict(x_test)\n",
        "print(accuracy_score(y_train1,train_pred))\n",
        "print(accuracy_score(y_test,test_pred))"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "7Fvy6jn9cV3B"
      },
      "cell_type": "code",
      "source": [
        "'''lr.fit(x_train2, y_train2)\n",
        "train_pred= lr.predict(x_train2)\n",
        "test_pred= lr.predict(x_test)\n",
        "print(accuracy_score(y_train2,train_pred))\n",
        "print(accuracy_score(y_test,test_pred))'''"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "Y92H4BKocV3B"
      },
      "cell_type": "markdown",
      "source": [
        "### After Evaluation of Various parameters"
      ]
    },
    {
      "metadata": {
        "id": "Edslt5iPcV3B"
      },
      "cell_type": "markdown",
      "source": [
        "### Decision Tree"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "xZjFc_25cV3B"
      },
      "cell_type": "code",
      "source": [
        "import time\n",
        "from sklearn.metrics import f1_score\n",
        "from sklearn.metrics import fbeta_score\n",
        "estimator=  DecisionTreeClassifier(criterion= 'gini', max_depth=5, min_samples_split= 2)\n",
        "estimator.fit(x_train, y_train)\n",
        "model_score= estimator.predict(x_train)\n",
        "accuracy= estimator.predict(x_test)\n",
        "start = time.time()\n",
        "estimator.score(x_train, y_train)\n",
        "acc_random_forest = round(accuracy_score(y_test,accuracy)*100, 2)\n",
        "f1_random_forest = round(f1_score(y_test,accuracy,average = \"binary\")*100, 2)\n",
        "f_beta_random_forest = round(fbeta_score(y_test,accuracy,average = \"binary\",beta=0.5)*100, 2)\n",
        "\n",
        "end = time.time()\n",
        "\n",
        "acc_score.append({'Model':'Decision Tree', 'Score': accuracy_score(y_train, model_score), 'Accuracy': accuracy_score(y_test, accuracy), 'Time_Taken':end - start})"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "ifoxpLD7cV3B"
      },
      "cell_type": "code",
      "source": [
        "fn= ['InscClaimAmtReimbursed', 'IPAnnualReimbursementAmt',\n",
        "    'IPAnnualDeductibleAmt', 'OPAnnualReimbursementAmt',\n",
        "    'OPAnnualDeductibleAmt', 'Age', 'DaysAdmitted',\n",
        "    'TotalDiagnosis', 'TotalProcedure', 'EncounterType', 'Gender', 'Race',\n",
        "    'RenalDiseaseIndicator', 'ChronicCond_Alzheimer',\n",
        "    'ChronicCond_Heartfailure', 'ChronicCond_KidneyDisease',\n",
        "    'ChronicCond_Cancer', 'ChronicCond_ObstrPulmonary',\n",
        "    'ChronicCond_Depression', 'ChronicCond_Diabetes',\n",
        "    'ChronicCond_IschemicHeart', 'ChronicCond_Osteoporasis',\n",
        "    'ChronicCond_rheumatoidarthritis', 'ChronicCond_stroke', 'IsDead']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "C_s2PRwxcV3B"
      },
      "cell_type": "code",
      "source": [
        "cl=['No','Yes']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "7ejo4FuzcV3C"
      },
      "cell_type": "code",
      "source": [
        "fig, axes = plt.subplots(nrows = 1,ncols = 1,figsize = (15,10), dpi=300)\n",
        "tree.plot_tree(estimator, feature_names= fn, class_names=cl);"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "JXoEHyUmcV3C"
      },
      "cell_type": "markdown",
      "source": [
        "### Destandardizing Values"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "bzq93JTzcV3C"
      },
      "cell_type": "code",
      "source": [
        "m1= Master_df['DaysAdmitted'].mean()\n",
        "s1= Master_df['DaysAdmitted'].std()\n",
        "print((0.007*s1)+m1)\n",
        "print((9.57*s1)+m1)\n",
        "print((9.135*s1)+m1)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "jYiT5n-icV3C"
      },
      "cell_type": "code",
      "source": [
        "m2= Master_df['OPAnnualDeductibleAmt'].mean()\n",
        "s2= Master_df['OPAnnualDeductibleAmt'].std()\n",
        "print((10.514*s2)+m2)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "vrzbSCW_cV3C"
      },
      "cell_type": "code",
      "source": [
        "m3= Master_df['Age'].mean()\n",
        "s3= Master_df['Age'].std()\n",
        "print((-0.481*s3)+m3)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "NpO9nNo8cV3C"
      },
      "cell_type": "code",
      "source": [
        "m4= Master_df['InscClaimAmtReimbursed'].mean()\n",
        "s4= Master_df['InscClaimAmtReimbursed'].std()\n",
        "print((10.075*s4)+m4)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "cm-SEk0kcV3C"
      },
      "cell_type": "code",
      "source": [
        "confusion_matrix(y_test,accuracy)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "pRZ1cCIAcV3C"
      },
      "cell_type": "code",
      "source": [
        "tn, fp, fn, tp = confusion_matrix(y_test,accuracy).ravel()\n",
        "(tn, fp, fn, tp)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "6bIu8yCVcV3C"
      },
      "cell_type": "code",
      "source": [
        "train_fpr, train_tpr, thresholds = roc_curve(y_train, estimator.predict_proba(x_train)[:,1])\n",
        "test_fpr, test_tpr, thresholds = roc_curve(y_test, estimator.predict_proba(x_test)[:,1])\n",
        "plt.plot(train_fpr, train_tpr, label=\"train AUC =\"+str(auc(train_fpr, train_tpr)))\n",
        "plt.plot(test_fpr, test_tpr, label=\"test AUC =\"+str(auc(test_fpr, test_tpr)))\n",
        "plt.legend()\n",
        "plt.xlabel(\"FPR\")\n",
        "plt.ylabel(\"TPR\")\n",
        "plt.title(\"ROC CURVE\")\n",
        "plt.show()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "_f65jRE1cV3C"
      },
      "cell_type": "markdown",
      "source": [
        "### Random Forest"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "hKtx-67bcV3C"
      },
      "cell_type": "code",
      "source": [
        "from sklearn.ensemble import RandomForestClassifier\n",
        "estimator1= RandomForestClassifier()\n",
        "estimator1.fit(x_train, y_train)\n",
        "model_score= estimator1.predict(x_train)\n",
        "accuracy= estimator1.predict(x_test)\n",
        "start = time.time()\n",
        "estimator1.score(x_train, y_train)\n",
        "acc_random_forest = round(accuracy_score(y_test,accuracy)*100, 2)\n",
        "f1_random_forest = round(f1_score(y_test,accuracy,average = \"binary\")*100, 2)\n",
        "f_beta_random_forest = round(fbeta_score(y_test,accuracy,average = \"binary\",beta=0.5)*100, 2)\n",
        "end = time.time()\n",
        "acc_score.append({'Model':'Random Forest', 'Score': accuracy_score(y_train, model_score), 'Accuracy': accuracy_score(y_test, accuracy),'Time_Taken':end - start})"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "wv7xMaqScV3C"
      },
      "cell_type": "code",
      "source": [
        "confusion_matrix(y_test,accuracy)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "Z8i1Jk9-cV3C"
      },
      "cell_type": "code",
      "source": [
        "tn, fp, fn, tp = confusion_matrix(y_test,accuracy).ravel()\n",
        "(tn, fp, fn, tp)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "6pwxZHXicV3C"
      },
      "cell_type": "code",
      "source": [
        "train_fpr, train_tpr, thresholds = roc_curve(y_train, estimator1.predict_proba(x_train)[:,1])\n",
        "test_fpr, test_tpr, thresholds = roc_curve(y_test, estimator1.predict_proba(x_test)[:,1])\n",
        "\n",
        "plt.plot(train_fpr, train_tpr, label=\"train AUC =\"+str(auc(train_fpr, train_tpr)))\n",
        "plt.plot(test_fpr, test_tpr, label=\"test AUC =\"+str(auc(test_fpr, test_tpr)))\n",
        "plt.legend()\n",
        "plt.xlabel(\"FPR\")\n",
        "plt.ylabel(\"TPR\")\n",
        "plt.title(\"ROC CURVE\")\n",
        "plt.show()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "4apv0wZGcV3C"
      },
      "cell_type": "code",
      "source": [
        "y_test_rf= y_test.reset_index()\n",
        "y_test.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "hTZ9urfacV3C"
      },
      "cell_type": "code",
      "source": [
        "x_test_rf=  x_test.reset_index()\n",
        "x_test.head()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "9j7riX1QcV3C"
      },
      "cell_type": "code",
      "source": [
        "y_test_rf.shape"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "Mm-QbeXpcV3C"
      },
      "cell_type": "code",
      "source": [
        "accuracy= accuracy.reshape(55822,1)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "t4bQJXLmcV3C"
      },
      "cell_type": "code",
      "source": [
        "accuracy.shape"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "gWKPeD-RcV3C"
      },
      "cell_type": "code",
      "source": [
        "accuracy= pd.DataFrame(accuracy, columns= ['Predict'])\n",
        "accuracy"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "lLoj4rlFcV3C"
      },
      "cell_type": "code",
      "source": [
        "predictor= pd.concat([y_test_rf,accuracy], axis=1)\n",
        "predictor"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "q6iujT3dcV3D"
      },
      "cell_type": "code",
      "source": [
        "Index_label = predictor[(predictor['PotentialFraud'] ==1) & (predictor['Predict']==1)]\n",
        "indicies= Index_label['index']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "VivBhBBjcV3D"
      },
      "cell_type": "code",
      "source": [
        "wrong_predictions= Master_df.iloc[indicies,:]\n",
        "wrong_predictions"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "zIkIRcEScV3D"
      },
      "cell_type": "code",
      "source": [
        "print('Fraud Insurance Claims detected - ',wrong_predictions['InscClaimAmtReimbursed'].sum())\n",
        "print('Fraud Insurance Claims for Inpatients detected - ',wrong_predictions['IPAnnualReimbursementAmt'].sum())\n",
        "print('Fraud Insurance Claims for Outpatients detected - ',wrong_predictions['OPAnnualReimbursementAmt'].sum())"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "cHQ15EHAcV3D"
      },
      "cell_type": "code",
      "source": [
        "fraud_index= y_test_rf[y_test_rf['PotentialFraud']==1]\n",
        "indicies1= fraud_index['index']"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "FzMtbSq1cV3D"
      },
      "cell_type": "code",
      "source": [
        "frauds= Master_df.iloc[indicies1,:]\n",
        "frauds"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "jl22jtyucV3D"
      },
      "cell_type": "code",
      "source": [
        "print('Fraud Insurance Claims without model - ',frauds['InscClaimAmtReimbursed'].sum())\n",
        "print('Fraud Insurance Claims for Inpatients without model - ',frauds['IPAnnualReimbursementAmt'].sum())\n",
        "print('Fraud Insurance Claims for Outpatients without model - ',frauds['OPAnnualReimbursementAmt'].sum())"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "FQLF1EZUcV3D"
      },
      "cell_type": "code",
      "source": [
        "print('Insurance Claim Amount Saved - $', 30673230- 23525520)\n",
        "print('Inpatient Insurance Claim Amount Saved - $',122946970- 78254980)\n",
        "print('Outpatient insurance Claim Amount Saved - $',48642580- 27754480)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "vMvTPcUucV3D"
      },
      "cell_type": "markdown",
      "source": [
        "### Naive Bayes"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "fJwFdYnNcV3D"
      },
      "cell_type": "code",
      "source": [
        "from sklearn.naive_bayes import GaussianNB\n",
        "bayes= GaussianNB()\n",
        "bayes.fit(x_train, y_train)\n",
        "train_pred= bayes.predict(x_train)\n",
        "test_pred= bayes.predict(x_test)\n",
        "start = time.time()\n",
        "bayes.score(x_train, y_train)\n",
        "acc_random_forest = round(accuracy_score(y_test,test_pred)*100, 2)\n",
        "f1_random_forest = round(f1_score(y_test,test_pred,average = \"binary\")*100, 2)\n",
        "f_beta_random_forest = round(fbeta_score(y_test,test_pred,average = \"binary\",beta=0.5)*100, 2)\n",
        "\n",
        "end = time.time()\n",
        "\n",
        "acc_score.append({'Model':'Naive Bayes', 'Score': accuracy_score(y_train, train_pred), 'Accuracy': accuracy_score(y_test, test_pred),'Time_Taken':end- start})"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "K-gpVxDdcV3D"
      },
      "cell_type": "code",
      "source": [
        "confusion_matrix(y_test,test_pred)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "vkmRaqfIcV3D"
      },
      "cell_type": "code",
      "source": [
        "tn, fp, fn, tp = confusion_matrix(y_test,test_pred).ravel()\n",
        "(tn, fp, fn, tp)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "nq8Db2MycV3D"
      },
      "cell_type": "code",
      "source": [
        "train_fpr, train_tpr, thresholds = roc_curve(y_train, bayes.predict_proba(x_train)[:,1])\n",
        "test_fpr, test_tpr, thresholds = roc_curve(y_test, bayes.predict_proba(x_test)[:,1])\n",
        "\n",
        "plt.plot(train_fpr, train_tpr, label=\"train AUC =\"+str(auc(train_fpr, train_tpr)))\n",
        "plt.plot(test_fpr, test_tpr, label=\"test AUC =\"+str(auc(test_fpr, test_tpr)))\n",
        "plt.legend()\n",
        "plt.xlabel(\"FPR\")\n",
        "plt.ylabel(\"TPR\")\n",
        "plt.title(\"ROC CURVE\")\n",
        "plt.show()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "-8B5tpzMcV3D"
      },
      "cell_type": "markdown",
      "source": [
        "### Logistic Regression"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "xWQ97495cV3D"
      },
      "cell_type": "code",
      "source": [
        "from sklearn.linear_model import LogisticRegression\n",
        "lr= LogisticRegression()\n",
        "lr.fit(x_train, y_train)\n",
        "train_pred= lr.predict(x_train)\n",
        "test_pred= lr.predict(x_test)\n",
        "start = time.time()\n",
        "lr.score(x_train, y_train)\n",
        "acc_random_forest = round(accuracy_score(y_test,test_pred)*100, 2)\n",
        "f1_random_forest = round(f1_score(y_test,test_pred,average = \"binary\")*100, 2)\n",
        "f_beta_random_forest = round(fbeta_score(y_test,test_pred,average = \"binary\",beta=0.5)*100, 2)\n",
        "\n",
        "end = time.time()\n",
        "acc_score.append({'Model': \"Logistic Regression\", 'Score': accuracy_score(y_train,train_pred), 'Accuracy': accuracy_score(y_test,test_pred), 'Time_Taken':end - start})"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "Qg_GupKQcV3D"
      },
      "cell_type": "code",
      "source": [
        "confusion_matrix(y_test,test_pred)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "fJFebqHvcV3D"
      },
      "cell_type": "code",
      "source": [
        "tn, fp, fn, tp = confusion_matrix(y_test,test_pred).ravel()\n",
        "(tn, fp, fn, tp)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "jsNgGQdzcV3E"
      },
      "cell_type": "code",
      "source": [
        "train_fpr, train_tpr, thresholds = roc_curve(y_train, lr.predict_proba(x_train)[:,1])\n",
        "test_fpr, test_tpr, thresholds = roc_curve(y_test, lr.predict_proba(x_test)[:,1])\n",
        "\n",
        "plt.plot(train_fpr, train_tpr, label=\"train AUC =\"+str(auc(train_fpr, train_tpr)))\n",
        "plt.plot(test_fpr, test_tpr, label=\"test AUC =\"+str(auc(test_fpr, test_tpr)))\n",
        "plt.legend()\n",
        "plt.xlabel(\"FPR\")\n",
        "plt.ylabel(\"TPR\")\n",
        "plt.title(\"ROC CURVE\")\n",
        "plt.show()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "id": "DAd4Hb0JcV3E"
      },
      "cell_type": "markdown",
      "source": [
        "### XG Boost"
      ]
    },
    {
      "metadata": {
        "trusted": true,
        "id": "9cAW3UmfcV3E"
      },
      "cell_type": "code",
      "source": [
        "xgb= XGBClassifier()\n",
        "xgb.fit(x_train, y_train)\n",
        "model_score= xgb.predict(x_train)\n",
        "accuracy= xgb.predict(x_test)\n",
        "start = time.time()\n",
        "xgb.score(x_train, y_train)\n",
        "acc_random_forest = round(accuracy_score(y_test,accuracy)*100, 2)\n",
        "f1_random_forest = round(f1_score(y_test,accuracy,average = \"binary\")*100, 2)\n",
        "f_beta_random_forest = round(fbeta_score(y_test,accuracy,average = \"binary\",beta=0.5)*100, 2)\n",
        "\n",
        "end = time.time()\n",
        "acc_score.append({'Model':'XG boost', 'Score': accuracy_score(y_train, model_score), 'Accuracy': accuracy_score(y_test, accuracy), 'Time_Taken':end - start})"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "-D9tJpimcV3E"
      },
      "cell_type": "code",
      "source": [
        "confusion_matrix(y_test,accuracy)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "ZH5xbuz9cV3E"
      },
      "cell_type": "code",
      "source": [
        "tn, fp, fn, tp = confusion_matrix(y_test,accuracy).ravel()\n",
        "(tn, fp, fn, tp)"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "gJwRhb7JcV3E"
      },
      "cell_type": "code",
      "source": [
        "train_fpr, train_tpr, thresholds = roc_curve(y_train, xgb.predict_proba(x_train)[:,1])\n",
        "test_fpr, test_tpr, thresholds = roc_curve(y_test, xgb.predict_proba(x_test)[:,1])\n",
        "\n",
        "plt.plot(train_fpr, train_tpr, label=\"train AUC =\"+str(auc(train_fpr, train_tpr)))\n",
        "plt.plot(test_fpr, test_tpr, label=\"test AUC =\"+str(auc(test_fpr, test_tpr)))\n",
        "plt.legend()\n",
        "plt.xlabel(\"FPR\")\n",
        "plt.ylabel(\"TPR\")\n",
        "plt.title(\"ROC CURVE\")\n",
        "plt.show()"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "bTHaxQIWcV3E"
      },
      "cell_type": "code",
      "source": [
        "accuracy= pd.DataFrame(acc_score, columns=['Model','Score','Accuracy','Time_Taken'])\n",
        "accuracy.sort_values(by='Accuracy', ascending= False, inplace= True)\n",
        "accuracy"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "LPsvVZ6EcV3E"
      },
      "cell_type": "code",
      "source": [
        "plt.figure(figsize=(15,8))\n",
        "sns.barplot(x= accuracy.Model, y=accuracy.Accuracy);"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "6DnLwavvcV3E"
      },
      "cell_type": "code",
      "source": [
        "import pickle"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "i5OGlniNcV3E"
      },
      "cell_type": "code",
      "source": [
        "pickle.dump(estimator1, open('model.pkl','wb'))\n",
        "\n",
        "model = pickle.load(open('model.pkl','rb'))"
      ],
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "id": "QDi4WVkscV3E"
      },
      "cell_type": "code",
      "source": [
        "print(model.predict([[6.542662,2.610838,2.234826,-0.571436,-0.578530,-0.519851,2.832646,2.446318,-0.190910,0,1,1,0,1,1,1,2,2,1,1,1,2,1,1,0.0]]))"
      ],
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "language": "python",
      "display_name": "Python 3",
      "name": "python3"
    },
    "language_info": {
      "pygments_lexer": "ipython3",
      "nbconvert_exporter": "python",
      "version": "3.6.4",
      "file_extension": ".py",
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "name": "python",
      "mimetype": "text/x-python"
    },
    "colab": {
      "name": "kernel83ef294a68",
      "provenance": [],
      "include_colab_link": true
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}